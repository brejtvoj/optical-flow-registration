import numpy as np
import torch
import torch.nn.functional as F

import matplotlib.pyplot as plt
from flow_visualization import flow2img
from visualize import plt_img_landmarks

from network import RAFTGMA
from utils_warp import warp
from census_loss import multiscale_census_loss
from register_local import RegisterImage as register_l
from register_global import register as global_module

from data_management import warp_landmarks_from_sample, get_all_paths, load_csv, load_image, gen_args
import time


class Datapoint():
    """Class fore data preparation between global and local registration."""

    def __init__(self, path1, path2, image1=None, landmarks1=None):
        self.data1 = landmarks1
        self.data2 = load_csv(path2)
        self.num_data = min(len(self.data1), len(self.data2))
        self.data1 = self.data1[:self.num_data]
        self.data2 = self.data2[:self.num_data]
        self.image = image1
        self.image_t = load_image(path2)
        self.flow_shape = self.image.shape[:2]
        self.interpolate_data()

    def interpolate_data(self):
        """Interpolate images to have the same size and scale landmarks."""
        shape_old = np.array(self.image_t.shape[:2])
        center_old = shape_old / 2

        self.image_t = torch.from_numpy(self.image_t).permute(2, 0, 1).unsqueeze(dim=0)
        self.image_t = F.interpolate(self.image_t, self.flow_shape)
        self.image_t = self.image_t.squeeze().permute(1, 2, 0).numpy()

        shape_new = np.array(self.image_t.shape[:2])
        center_new = shape_new / 2

        y_coeff = shape_new[0] / shape_old[0]
        x_coeff = shape_new[1] / shape_old[1]

        for i in range(self.num_data):
            y_old = self.data2[i][0]
            x_old = self.data2[i][1]
            y_new = y_coeff * (y_old - center_old[0]) + center_new[0]
            x_new = x_coeff * (x_old - center_old[1]) + center_new[1]
            self.data2[i] = (y_new, x_new)


def register_local_only(path1, path2, image_format='.png', visualize=False):
    """Skip the global registration."""
    data = Datapoint(path1, path2)
    landmarks_1 = data.data1
    landmarks_2 = data.data2
    max_len = min(len(landmarks_1), len(landmarks_2))
    landmarks_1 = landmarks_1[:max_len]
    landmarks_2 = landmarks_2[:max_len]
    image_original, image_target, image_warp, flow = register_l(
        path1 + image_format, path2 + image_format, scale=None)

    landmarks_W = warp_landmarks_from_sample(flow, landmarks_1)
    return landmarks_W, landmarks_2, image_warp, flow


def register_global_to_patch(path1, path2, model_type,
                             model_path_global, local_module,
                             visualize=False):
    """
    Implement the overall registration method as proposed in our paper.

    Global -> Local registration. If global module fails, skip into the
    local-only mode.

    Parameters
    ----------
    path1 : string
        Location of the first image and landmarks.
    path2 : string
        Location of the second image and landmarks.
    model_type : nn.Module
        Type of the architecture (RAFT / GMA).
    model_path_global : string
        Location of the global network.
    local_module : nn.Module (loaded)
        Loaded PyTorch network.
    visualize : bool
        Determin, wheter to show intermediate steps.

    Returns
    -------
    images : tuple of ndarrays
        Images after different steps of the registration.
    f : Tensor
        Flow generated by course-to-fine approach.
    landmarks_original : list of tuples
        Landmarks of the original image.
    landmarks_global : list of tuples
        Landmarks after the global registration.
    landmarks_local : ;ist of tuples
        Landmarks after the local registration.
    landmarks_local_only : list of tuples
        Landmarks after the local-only registration.
    shapes : tuple of tuples
        Sizes of images during the registration process.
    chosen : tuple of various
        Flow, warped image and warped landmarks chosen based on the census loss.
    """
    # Preparation
    landmarks1 = load_csv(path1)
    landmarks2 = load_csv(path2)
    n_landmarks = min(len(landmarks1), len(landmarks2))
    landmarks1 = landmarks1[:n_landmarks]
    landmarks2 = landmarks2[:n_landmarks]

    image1 = load_image(path1)
    image2 = load_image(path2)
    shape_original = image1.shape[:2]
    landmarks_original = (landmarks1, landmarks2)

    # Original census loss
    i1c = torch.from_numpy(image1).permute(2, 0, 1).unsqueeze(dim=0).float()
    i2c = torch.from_numpy(image2).permute(2, 0, 1).unsqueeze(dim=0).float()
    i2c = F.interpolate(i2c, (i1c.shape[0], i1c.shape[1]))
    flow_null = torch.zeros((2, image1.shape[0], image1.shape[1]))
    c1 = multiscale_census_loss(image1, image2, flow_null)

    if visualize:
        plt_img_landmarks(image1, landmarks1)

    # Global registration
    coeff = 0.3
    model = model_type(gen_args())
    model.load_state_dict(torch.load(model_path_global), strict=False)
    flow, _, _, _, _, _ = global_module(path1, path2,
                                        model_type, model_path_global, coeff,
                                        landmarks1=landmarks1,
                                        landmarks2=landmarks2)

    landmarksW_global = warp_landmarks_from_sample(flow.squeeze().detach().cpu(),
                                                   landmarks1)

    imageW_global = warp(torch.from_numpy(image1).permute(2, 0, 1).unsqueeze(dim=0).float(),
                         flow.float())

    imageW_global = imageW_global.squeeze().permute(1, 2, 0).cpu().detach().numpy()

    if visualize:
        plt_img_landmarks(imageW_global / 255, landmarksW_global)

    # Global census loss
    c2 = multiscale_census_loss(imageW_global, image2, flow_null)

    with torch.no_agrad():
        r = c2.item() / c1.item()

    # Preparation
    data = Datapoint(path1, path2, imageW_global, landmarksW_global)
    image1g = np.transpose(data.image, (2, 0, 1))
    image2g = np.transpose(data.image_t, (2, 0, 1))
    landmarksW_global = data.data1
    landmarks2_global = data.data2
    landmarks_global = (landmarksW_global, landmarks2_global)

    # Local registration
    io, it, iw, f = local_module(image1g, image2g, scale=None)
    f_img = f.detach().squeeze().cpu().numpy()
    f_img = flow2img(f_img)
    plt.imshow(f_img)
    plt.xticks([])
    plt.yticks([])
    plt.box(None)
    plt.show()
    shape_local = io.shape[1:]
    landmarksW_local = warp_landmarks_from_sample(f, landmarksW_global)
    landmarks_local = (landmarksW_local, landmarks2_global)

    if visualize:
        iw_vis = iw.cpu().permute(1, 2, 0).numpy()
        plt_img_landmarks(iw_vis / 255, landmarksW_local)
        image2_vis = np.transpose(image2, (1, 2, 0))
        plt_img_landmarks(image2_vis, landmarks2_global)

    # Local-only registration
    lmW, lm2, image_local_only, flow_local_only = register_local_only(path1, path2)
    landmarks_local_only = (lmW, lm2)

    images = (io, it, iw)
    shapes = (shape_original, shape_local, shape_local)

    # Choose the flow, warped image and landmarks based only on the census loss
    if r < 0.9:
        f_chosen = flow_local_only
        lm_chosen = lmW
        image_chosen = image_local_only
    else:
        f_chosen = f
        lm_chosen = landmarksW_local
        image_chosen = iw
    chosen = (f_chosen, lm_chosen, image_chosen)

    return images, f, landmarks_original, landmarks_global, landmarks_local, landmarks_local_only, shapes, chosen


def calc_measure(landmarks1, landmarks2, image_shape):
    """Calculate several basic measure, for the purpose of the printing only."""
    if isinstance(landmarks1, list):
        landmarks1 = np.array(landmarks1)
    if isinstance(landmarks2, list):
        landmarks2 = np.array(landmarks2)
    EPE = np.linalg.norm(landmarks1 - landmarks2, ord=2, axis=1)
    rTRE = EPE / np.sqrt(image_shape[0]**2 + image_shape[1]**2)
    return np.median(EPE), np.median(rTRE)


# Example of use
if __name__ == "__main__":
    path = None
    pairs = get_all_paths(path)
    model_type = RAFTGMA
    model_path_global = None
    model_path_patch = None

    landmarks_original_all = list()
    landmarks_global_all = list()
    landmarks_local_all = list()
    landmarks_local_only_all = list()
    shapes_all = list()

    local_module = register_l(RAFTGMA, model_path_patch, gen_args())
    for i, pair in enumerate(pairs):
        t1 = time.time()
        path1, path2 = pair
        blob = register_global_to_patch(path1, path2, RAFTGMA,
                                        model_path_global, local_module)
        images, f, landmarks_original, landmarks_global, landmarks_local, landmarks_local_only, shapes = blob
        t2 = time.time()
        l1o, l2o = landmarks_original
        l1g, l2g = landmarks_global
        l1l, l2l = landmarks_local
        l1lo, l2lo = landmarks_local_only

        print(f'{i + 1} / {len(pairs)} | TIME: {(t2 - t1):.2f} s')
        print('Original: ', calc_measure(l1o, l2o, shapes[0]))
        print('Global: ', calc_measure(l1g, l2g, shapes[0]))
        print('Local: ', calc_measure(l1l, l2l, shapes[2]))
        print('Local Only: ', calc_measure(l1lo, l2lo, shapes[2]))
        print()

        landmarks_original_all.append(landmarks_original)
        landmarks_global_all.append(landmarks_global)
        landmarks_local_all.append(landmarks_local)
        landmarks_local_only_all.append(landmarks_local_only)
        shapes_all.append(shapes)